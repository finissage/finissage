# volatile 和 synchronized 的区别
## volatile 和 synchronized 特点
首先需要需要理解线程安全的两个方面: ***执行控制*** 和 ***内存可见***。  

***执行控制*** 的目的是控制代码执行(顺序)及是否可以并发执行。  

***内存可见*** 控制是线程执行结果在内存中对其他线程的可见性,根据`java内存模型`的实现,线程在具体执行时,会先拷贝主内存数据到线程本地(CPU缓存),操作完成后把结果从线程本地刷新到主内存。
`synchronized` 关键字解决的是执行控制问题,他会组织其他线程获取当前对象的监控锁,这样就似的当前对象中被`synchronized` 关键字保护的代码无法被其他线程访问,也就无法并发执行,从而保证了操作的内存可见性,同时也使得先获得这个所的线程的所有操作,

`volatile` 关键字解决的是内存可见性的问题,会使得所有 `volatile` 变量的读写都直接刷新到主内存,及保证了变量的可见性。这样能满足一些对变量可见性有要求而对读取顺序没有要求的需求。

使用 `colatole` 关键字仅能实现对原始变量(如`boolen`,`shor`,`int`,`long`等)操作的原子性。但需要特别注意,`volatile`不能保证符合操作的原子性,及时只是 `i++`,实际上也是有多个原子操作组成:`read i; inc; write i;` 加入多个线程同时执行 `i++`, `volatile` 只能保证他们操作的`i` 是同一内存,但依然可能出现写入脏数据的情况。

在`java 5` 提供了原子数据类型`atomic wrapper classes`, 对他们的`increase` 之类的操作都是原子操作,不需要使用 `synchronized` 关键字。

对于`volatole` 关键字,当且今当满足一下所有条件可使用:
>1. 对变量的写入操作不依赖变量的当前值,或者你能确保只有单个线程更新变量的值。
>2. 该变量没有包含在具有其他变量的不变式中。

## volatile 和 synchronized 的区别
1. `volatile` 本质是在告诉 `jvm` 当前变量在寄存器(工作内存)中的值是不确定的。需要从内存中读取；`synchronized` 则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住。
2. `volatile` 仅能使用在变量级别,`synchronized` 则可以使用变量,方法,和类级别的。
3. `volatile` 仅能实现变量的修改可见性,不能保证原子性；而`synchronized` 则可以保证变量的修改可见性和原子性。
4. `volatile` 不会操作线程的阻塞; `synchronized`可能会操作线程的阻塞。
5. `volatile` 标记的变量不会编译器优化;`synchroinzed` 标记的变量可以被编译器优化