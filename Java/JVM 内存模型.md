# JVM

## 各个区域的作用  
![JVM内存图](../1.jpg)
程序计数器：
    较小的内存空间，当前线程执行的字节码的行号指示器，个线程之间独立存储，互不影响
虚拟机栈：
    线程私有，生命周期和线程，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。方法的执行就对应着栈帧在虚拟机栈帧中入栈和出栈的过程，栈里边存放着各种基本数据和对象的引用
本地方法栈：
    本地方法保存的事`native`方法的信息，当一个JVM创建的线程调用`native`方法后，JVM不在未起在虚拟机栈中创建栈帧，JVM只是简单动态链接并直接调用`navite`方法。
堆内存：
    Java堆是Javaer需要重点关注的一块区域，因为涉及到内存的分配（new 关键字，反射等）与回收（回收算法，收集器等）（`-Xms; -Xmx; -Xmn; -XX:NewSize; -XX:MaxNewSize;`）
方法区：
    也叫永久区，用户存储已经被虚拟机加载的类信息，常量，静态变量等数据（`-XX:PermSize; -XXLMaxPermSize; -XX:MetaspaceSize; -XX:MaxMetaspaceSize`）.
运行时常量池
    属于方法区的以部门

### 栈帧
局部变量表
    用于存放方法的入参及方法内部定义的参数，编译是确定大小，
操作数栈
    用户方法运算和取值、赋值操作的地方
动态链接
    存放着方法的引用
返回地址
    方法有两种结束方式：正常退出，如果有返回值则将返回值返回（方法调用者）,异常返回返回到异常处理器


## GC  
###  谁需要GC** 
堆、方法区

### 判断对象得存活的两种方式
#### 1.对象计数法
    对象的每次引用引用计数就+1 当计数器为0时 可定义为不存活
    缺点：相互引用 
#### 2.可达性分析
    没有被GC ROOTS 对象所引用的对象 可定义为对象不存活
    GC ROOT 对象：
        1. 方法区：类静态属性引用的对象。
        2. 方法区：常量引用的对象；
        3. 虚拟机栈（本地变量表）中引用的对象。
        4. 本地方法栈JNI（Native方法）中一引用的对象。

### 各种引用
强引用
    Person p = new Person();
软引用
    一些有用 但是并非必须，用软引用关联，系统将发生OOM之前，这些对象就会被回收。
弱引用
    一些有用 但是并非必须，用弱引用，只会经历一次GC  第二次GC 将会回收
虚引用

## 垃圾回收算法
1. 标记清除算法
    * 缺点：过多的碎片空间
    * 优点：简单
2. 复制算法
    * 浪费空间 只能使用50% 
    * 内存中专问题（复制对象）
3. 标记整理算法
    
|收集器|手机对象和算法|收集器类型|说明|使用场景|
 