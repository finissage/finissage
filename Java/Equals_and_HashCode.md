# Equals 和 HashCode 解析 
### 覆盖 Equals 时需要遵守的通用约定：
覆盖`equals`方法看起来很简单,但是如果覆盖不当会导致错误,并且后果相当严重,`<Effective Java>`一书中提到“最容易避免这类问题的办法就是不覆盖`equals`方法”,这句话貌似很搞笑,起始想想也不无道理,起始在这种情况下,类的每个实例都只与他自身相等,如果满足了一下任何一个条件,这就正式所期望的结果。
- **类的每个实例本质上都是唯一的**。对于代表活动实体而不是值的类来说确实如此,例如`Thread`、`Object`提供的`Equals`实现对于这些类来说正确的行为。
- **不关心类是否提供了“逻辑相等”的测试功能**。假如`Random`覆盖了`equals`,以检查两个`Random`实例是否产生宣布该提相同的随机数序列,但是设计者并不认为客户小或者期望这样的功能,在这样的情况下,从`Object`继承得到的`Equals`实现已经足够了。
- **超累已经覆盖了Equals,从超累继承过来的行为对于子类是合适的。**大多数的 `Set`实现都从`AbstractSet`继承`Equals`实现,`List`实现从`AbstractList`继承`Equals`实现,`Map`实现从`AbstractMap`继承`Equals`实现。
- **类是私有的或者是包级私有的,可以确定他的Equals方法永远不会被调用**.、在这种情况下,五一是应该覆盖`Equals`方法的以防他被意外调用：
```java
public boolean equals(Object o) {
	throw new AssertionError(); // Method is never called
}
```

在覆盖`equals`方法的时候,你必须要遵守他的通用约定,下面是约定的内容,来自`Objevt`的规范[JavaSE6]
- **反弹性** 对于任何非`null`的引用x,`x.equals(x)`必须返回`true`.
- **对称性** 对于任何非`null`的引用值`x`和`y`,当且当`y.equals(x)`返回`true`时,必须返回`true`
- **传递性** 对于任何非`null`的引用值`x`、`y`、和`z`,如果`x.equals(y)`返回`true`,并且`y.equals(z)`也返回`true`,那么`x.equals(z)`也必须返回`true`,或者一直第返回`false`；
- 对于任何非`null`的引用值`x`,`x.equals(null)`必须返回`false`；

### 结合以上要求,得出了一下实现该质量`equals`方法的诀窍；
1. **使用 == 符号检查“茶树是否为这个对象的引用”**, 如果是,则返回`true`,这只不过是一种性能优化,如果比较操作有可能很昂贵,就值得这么做。
2. **使用`instanceof`操作符检查“参数是否为正确的类型”**。如果不是,则返回`false`。一般来说,所谓"正确的类型"是指`equals`方法所在的那个类。
3. **把参数转换成正确的类型**。 因为转换之前进行过`instanceof`测试,所以确保会成功。
4. **对于该类中的每个“关键”域,检查参数中的域是否与该对象中对应的域相匹配,**如果这些测试全部成功,则返回`true`,否则返回`false`.
5. 当编写完成了`equals`方法之后,检查“对称性”、“传递性”、“一致性”。

注意：
- 覆盖`equals`时总要覆盖`hashCode`
- 不要企图让`equals`方法过于只能。
- 不要将`equals`声明中的 `Object`对象替换成其他的类型,(因为这样我们并没有覆盖`Object`中的`equals`方法)

### 覆盖 equals 时总要覆盖  HashCode
一个很常见的错误根源在于没有覆盖`HashCode`方法,在每个覆盖了`equals`方法的类中,也必须覆盖`HashCode`方法.如果不这样做的话,就会违反`Object.hashCode`的通用约定,从而导致该类无法结合所有基于散列集合一起正常运作,这样的集合包括`HashMap`、`HashSet`和`HashTable`.
- 在应用程序的执行期间,只有对象的`equals`方法的比较操作用到的信息没有被修改,没有对这同一个对象,调用多次,`hashCode`方法都必须始终如一地返回同一个整数,在同一个应用程序的多次执行中,每次执行返回的整数可以不一致。
- 如果两个对象根据`equals()`方法比较是相等的,那么调用两个对象中任意一个对象的`hashCode`方法,则不一定产生相同的整数结果,但是程序员应该知道,给不同相等的对象产生截然不同的证书结果,有可能提高散列表的性能。